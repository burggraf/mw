We're using mdns to discover display devices on the local network. (For this document, the words "screen", "screens", "display", "displays" should be synonymous.)
That's working, but we need some changes.
First, each device on the network (which could be a laptop or desktop computer running MacOS, Windows, or maybe even Linux, or an Android TV device such as an Amazon Firestick, Google TV, etc, or a mobile device such as an iPhone, iPad, android phone, or android tablet) we need to have that device broadcast, via mdns, every one of it's available screens.  So a computer running MacOS may be a laptop that has a primary (LCD) screen, and one or more external screens, connected through HDMI cables, or through AirPlay links, or whatever.  We want to track "displays" and not "devices" so if a laptop has a primary screen plus 2 attached external devices, we want to broadcast 3 separate "displays" even though they're all attached to the same computer running on the same ip address.
This means we will need to be able to address websocket traffic individually to all 3 of those screens, routing it all through the websocket server running on the one laptop device on one IP address.
Each "display" should be given it's own unique UUID id for tracking purposes, so if we see a display available on the network that we've seen before, we can reference a database record for that display the supabase public.displays table.
Each display should advertise itself on mdns and should be identifiable via its UUID id (which should be stored in localstorage on the device) but that means that, when Rust identifies the hardware (the attached screens) that it'll need to "fingerprint" each device so it knows what UUID goes with which screen.  I don't know how that's going to work, but you'll need to figure out how to uniquely identify screens and be as accurate as possible.  One potential issue could be that a computer has 2 external display ports, and one day screen A may be attached to port 1 and screen B may be attached to port 2, but the next day they may be reversed.  Ideally we'd be able to detect the actual screen based on some factor (manufacturer, serial number, whatever) in order to distinguish which screen goes with which UUID.
In addition to broadcasting each screen's UUID, we want to broadcast as much other information about the screen as possible (whatever Rust hardware-level calls can get) such as manufacturer name, or model number or whatever we can get. (Research this on the web if necessary.) We definitely need screen height and width if we can get that.  We want to track as many attributes about each screen as necessary (with height/width in pixels being the most important) in the supabase public.displays table.
We also want to track the online/offline status of each display attached to the network, so in real time we should be able to see if the screen is online or offline.
Right now we're handling screens in the sidebar (under the Displays header).  Let's move that to a dedicated displays page, so clicking on "Displays" in the sidebar should bring up this new page that shows a complete list of all displays from the database (public.displays table) as well as any displays we've discovered on the network (but have not been added to the displays table yet.)
We should be able to add any discovered display to the database from this page, and we should be able to view any display's attributes from this page as well (and edit them if we need to.)
Finally, we need to be able to send websocket traffic to each individual display (even if multiple displays are attached to the same device/ip address) so that we can control each display separately.