# Android TV Display App Design

**Goal:** Create an Android TV app for FireTV devices that serves as a display-only client, receiving content from controllers via WebRTC.

**Approach:** Single codebase with runtime mode detection - Tauri 2.0's Android support builds the same React app for both desktop (controller) and Android TV (display).

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                         Shared Codebase                          │
│  React, TypeScript, Tailwind, Shadcn UI, WebRTC, Types, etc.   │
└─────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
                        ┌──────────────────────┐
                        │  Platform Detection  │
                        │  (Tauri API)         │
                        └──────────────────────┘
                                   │
                ┌──────────────────┴──────────────────┐
                ▼                                      ▼
┌───────────────────────────┐           ┌───────────────────────────┐
│      Controller Mode      │           │       Display Mode        │
│      (Desktop/macOS)      │           │       (Android TV)        │
├───────────────────────────┤           ├───────────────────────────┤
│ • Full UI routing         │           │ • Minimal UI              │
│ • Supabase auth           │           │ • No auth                 │
│ • Songs, Events, Settings │           │ • Pairing/Waiting screens │
│ • Display management      │           │ • D-pad navigation        │
│ • Control functionality   │           │ • TV menu (SELECT/BACK)   │
└───────────────────────────┘           └───────────────────────────┘
```

---

## Project Structure

```
src/
├── main.tsx                 # Routes to controller/display mode
├── platform/
│   └── index.ts             # Platform detection (get_platform)
├── modes/
│   ├── controller/
│   │   └── index.tsx        # Existing app (Auth, routing, etc.)
│   └── display/
│       └── index.tsx        # Display mode entry (Android TV)
├── components/
│   └── display/             # Display-specific components
│       ├── PairingScreen.tsx
│       ├── WaitingScreen.tsx
│       ├── ActiveDisplay.tsx
│       └── TVMenu.tsx
└── hooks/
    └── useWebRTC.ts         # Extended for display mode

src-tauri/
├── gen/android/             # Generated by Tauri (Android project)
│   └── app/
│       └── src/main/
│           └── AndroidManifest.xml  # TV launcher config
├── src/
│   ├── commands.rs          # get_platform command
│   └── main.rs              # Register Android commands
├── Cargo.toml               # Android dependencies
└── tauri.conf.json          # Android bundle config
```

---

## Platform Detection & Routing

### Platform Module (`src/platform/index.ts`)

```typescript
import { invoke } from '@tauri-apps/api/core';

export type Platform = 'desktop' | 'android-tv';
export type AppMode = 'controller' | 'display';

export async function detectPlatform(): Promise<Platform> {
  try {
    const platform = await invoke('platform'); // Rust command
    return platform === 'android' ? 'android-tv' : 'desktop';
  } catch {
    return 'desktop'; // Fallback for web/dev
  }
}

export function getMode(platform: Platform): AppMode {
  return platform === 'android-tv' ? 'display' : 'controller';
}
```

### Main Entry (`src/main.tsx`)

```typescript
import { getAppMode } from '@/platform';
import { ControllerApp } from './modes/controller';
import { DisplayApp } from './modes/display';

async function main() {
  const mode = await getAppMode();

  ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
      {mode === 'controller' ? <ControllerApp /> : <DisplayApp />}
    </React.StrictMode>
  );
}

main();
```

---

## Display Mode UI

### Display States

1. **Unpaired** - `PairingScreen`
   - Shows QR code and 6-digit pairing code
   - WebRTC advertisement to signaling server
   - D-pad navigation to manual code entry

2. **Paired/Idle** - `WaitingScreen`
   - Display name and location
   - "Waiting for event..." message
   - Connection status indicator

3. **Active** - `ActiveDisplay`
   - Lyrics/content from controller
   - Full-screen content rendering
   - No controls (receive-only)

4. **Menu Open** - `TVMenu` overlay
   - Triggered by SELECT or BACK button
   - D-pad navigable options

### TV Menu Options

| Option | Condition | Action |
|--------|-----------|--------|
| Resume | Paired | Close menu, return to display |
| Pair | Unpaired | Show pairing screen |
| Unpair | Paired | Disconnect, return to pairing |
| About | Always | Show app info |
| Exit | Always | Exit application |

### D-pad Controls

```
SELECT (Enter)     → Toggle menu
BACK (Escape)      → Toggle menu
Arrow Up/Down      → Navigate menu items
Enter              → Select menu item
```

---

## Tauri Android Configuration

### Cargo.toml

```toml
[target.'cfg(target_os = "android")'.dependencies]
tauri = { version = "2.0", features = ["android-native-activity"] }
```

### tauri.conf.json

```json
{
  "bundle": {
    "active": true,
    "targets": ["all", "android"],
    "android": {
      "minSdkVersion": 21,
      "versionCode": 1
    }
  },
  "app": {
    "windows": [{
      "title": "Mobile Worship Display",
      "width": 1920,
      "height": 1080,
      "decorations": false,
      "transparent": false,
      "fullscreen": true
    }]
  }
}
```

### AndroidManifest.xml

```xml
<manifest>
    <!-- TV Features -->
    <uses-feature
        android:name="android.software.leanback"
        android:required="true" />
    <uses-feature
        android:name="android.hardware.touchscreen"
        android:required="false" />

    <application>
        <activity
            android:name=".MainActivity"
            android:banner="@drawable/banner"
            android:icon="@mipmap/ic_launcher"
            android:label="@string/app_name"
            android:launchMode="singleTask">

            <!-- TV Launcher -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LEANBACK_LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>
```

### Rust Platform Command

```rust
#[tauri::command]
pub async fn get_platform() -> String {
    #[cfg(target_os = "android")]
    return "android".toString();

    #[cfg(not(target_os = "android"))]
    return "desktop".toString();
}
```

---

## WebRTC Display Flow

```
Android TV (Display)
      │
      │ 1. Generate 6-digit pairing code
      ▼
WebRTC Signaling
      │
      │ 2. PairingAdvertisement { pairing_code, device_id }
      ▼
Controller (Desktop)
      │
      │ 3. User enters code, connects to display
      ▼
WebRTC P2P Connection
      │
      │ 4. Display heartbeat every 5s
      ▼
Active Event
      │
      │ 5. Controller sends DisplayContent { lyrics, media }
      ▼
Android TV renders content
```

### Display Signaling Messages

**Outbound (Display → Signaling):**
- `PairingAdvertisement` - Announce availability with pairing code
- `DisplayHeartbeat` - Keep-alive every 5 seconds

**Inbound (Signaling → Display):**
- `PairingRequest` - Controller wants to connect
- `DisplayContent` - Lyrics/media to display
- `EventStart` - Event has started
- `EventEnd` - Event has ended

---

## Build & Development

### NPM Scripts

```json
{
  "tauri:android:dev": "tauri android dev",
  "tauri:android:build": "tauri android build",
  "tauri:android:install": "tauri android build --apk && adb install -r src-tauri/gen/android/app/build/outputs/apk/debug/app-debug.apk"
}
```

### Development Workflow

```bash
# Desktop (controller mode)
pnpm tauri:dev

# Android TV dev (requires connected device/emulator)
pnpm tauri:android:dev

# Build release APK
pnpm tauri:android:build

# Install to FireTV via ADB
adb connect 192.168.1.xxx:5555
adb install -r app-x.x.x-arm64-v8a-release.apk
```

### FireTV ADB Setup

1. Enable ADB on FireTV: Settings > My Fire TV > Developer Options > ADB Debugging
2. Get IP: Settings > My Fire TV > Network
3. Connect: `adb connect <IP>:5555`
4. Install: `adb install -r app-release.apk`

---

## Implementation Checklist

- [ ] Add `get_platform` Tauri command
- [ ] Create `src/platform/index.ts` detection module
- [ ] Create `src/modes/display/index.tsx` display entry
- [ ] Create `src/modes/controller/index.tsx` controller entry
- [ ] Update `src/main.tsx` with mode routing
- [ ] Create `PairingScreen` component (QR + code)
- [ ] Create `WaitingScreen` component
- [ ] Create `ActiveDisplay` component
- [ ] Create `TVMenu` component with D-pad nav
- [ ] Initialize Tauri Android: `pnpm tauri android init`
- [ ] Configure `AndroidManifest.xml` for TV (LEANBACK_LAUNCHER)
- [ ] Update `tauri.conf.json` with Android config
- [ ] Add Android-specific dependencies to `Cargo.toml`
- [ ] Extend WebRTC for display mode signaling
- [ ] Implement display heartbeat (5s interval)
- [ ] Add D-pad key listeners (SELECT/BACK/Arrow keys)
- [ ] Test on FireTV device
- [ ] Add translations for TV UI strings

---

## Success Criteria

1. **APK builds** - `pnpm tauri:android:build` produces installable APK
2. **Installs on FireTV** - `adb install` succeeds, app appears in launcher
3. **Display mode auto-starts** - No auth, goes straight to pairing screen
4. **Pairing works** - Controller can enter 6-digit code to connect
5. **Content displays** - Lyrics/media render correctly from controller
6. **D-pad navigation** - Menu works with FireTV remote
7. **Heartbeats** - Display stays connected, controller sees online status
